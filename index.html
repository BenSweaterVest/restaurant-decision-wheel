<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Spin the wheel to decide where to eat! A fun and easy way to choose restaurants.">
    <title>Restaurant Picker</title>
    <link rel="icon" type="image/png" href="https://thesweatervest.com/wp-content/uploads/2025/02/SweaterVest-Solutions-WIDECROP-300x300.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="https://thesweatervest.com/wp-content/uploads/2025/02/SweaterVest-Solutions-WIDECROP-300x300.png">
    <style>
        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: #ffffff;
            --text-primary: #333;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --input-bg: #fff;
            --input-border: #ced4da;
            --wheel-bg: #fff;
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --card-bg: #0f3460;
            --text-primary: #e8e8e8;
            --text-secondary: #b0b0b0;
            --border-color: #3a506b;
            --input-bg: #1a1a2e;
            --input-border: #3a506b;
            --wheel-bg: #1c2841;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: none;
        }

        .container.active {
            display: flex;
            gap: 20px;
        }

        .main-content {
            flex: 1;
            background: var(--card-bg);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .sidebar {
            width: 300px;
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .wheel-container {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 0 auto 40px;
        }

        #wheelCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 40px solid #ff6b6b;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
            z-index: 10;
        }

        .controls {
            text-align: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 0.9em;
        }

        .btn-secondary {
            background: #6c757d;
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .btn-danger {
            background: #dc3545;
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .btn-success {
            background: #28a745;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
            min-height: 100px;
        }

        .result h2 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .result p {
            color: #6c757d;
            margin: 5px 0;
        }

        .sidebar h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .profile-section {
            margin-bottom: 30px;
        }

        .autocomplete-wrapper {
            position: relative;
            width: 100%;
        }

        .profile-section input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
            background: white;
            box-sizing: border-box;
        }

        .profile-section input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ced4da;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .autocomplete-suggestions.active {
            display: block;
        }

        .autocomplete-suggestion {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.highlighted {
            background: #f8f9fa;
        }

        .autocomplete-suggestion.selected {
            background: #e7f3ff;
            font-weight: 500;
        }

        .filter-group {
            margin-bottom: 30px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            transition: background 0.2s;
        }

        .filter-group label:hover {
            background: #f8f9fa;
        }

        .filter-group input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
        }

        .btn-icon {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            margin-left: 10px;
            transition: transform 0.2s;
            vertical-align: middle;
        }

        .btn-icon:hover {
            transform: scale(1.2);
        }

        .admin-section {
            border-top: 1px solid #dee2e6;
            padding-top: 20px;
            margin-top: 20px;
        }

        /* Service Type Wheel Styles */
        .service-wheel-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 20px auto;
        }

        #serviceWheelCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .wheel-pointer-small {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #ff6b6b;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
            z-index: 10;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        .admin-panel {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .admin-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .form-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #495057;
            font-weight: 500;
        }

        /* Add subtle shadow to major section groups */
        .form-group.section-group {
            background: var(--input-bg);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .form-group.section-group:last-child {
            margin-bottom: 15px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
        }

        .form-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .checkbox-group label {
            display: inline-flex;
            align-items: center;
        }

        /* Food types - one per line for better readability */
        .checkbox-group.food-types-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-group.food-types-list label {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .checkbox-group.food-types-list label:hover {
            background: #f8f9fa;
        }

        .restaurant-list {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .restaurant-item {
            padding: 10px;
            background: white;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .restaurant-item-info {
            flex: 1;
        }

        .restaurant-item-name {
            font-weight: bold;
            color: #667eea;
        }

        .restaurant-item-types {
            font-size: 0.85em;
            color: #6c757d;
        }

        .login-form {
            margin-bottom: 20px;
        }

        .unsaved-changes-banner {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            font-size: 0.95em;
        }

        .unsaved-changes-banner.active {
            display: flex;
        }

        .unsaved-changes-count {
            font-weight: bold;
            color: #856404;
        }

        .save-actions {
            display: none;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #dee2e6;
        }

        .save-actions.active {
            display: flex;
        }

        .restaurant-item.modified {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
        }

        .restaurant-item.pending-add {
            background: #d4edda;
            border-left: 3px solid #28a745;
        }

        .restaurant-item.pending-delete {
            background: #f8d7da;
            border-left: 3px solid #dc3545;
            opacity: 0.7;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            color: #6c757d;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .footer-left {
            flex: 1;
        }

        .footer-center {
            flex: 1;
            text-align: center;
        }

        .footer-right {
            flex: 1;
            text-align: right;
        }

        .footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .footer a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container.active {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
            }

            .wheel-container {
                width: 100%;
                height: auto;
                aspect-ratio: 1;
                max-width: 400px;
            }

            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <!-- Service Type Wheel Modal -->
    <div id="serviceWheelModal" class="modal">
        <div class="modal-content">
            <h2>Spin for Service Type!</h2>
            <div class="service-wheel-container">
                <div class="wheel-pointer-small"></div>
                <canvas id="serviceWheelCanvas"></canvas>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="spinServiceBtn" onclick="spinServiceWheel()">Spin!</button>
                <button class="btn btn-secondary" style="margin-left: 10px;" onclick="closeServiceWheel()">Cancel</button>
            </div>
            <div id="serviceResult" style="margin-top: 20px; text-align: center; font-size: 1.2em; color: #667eea; font-weight: bold;"></div>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModal" class="modal">
        <div class="modal-content">
            <h2>Admin Login</h2>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="adminPassword" placeholder="Enter admin password">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-success" onclick="login()">Login</button>
                <button class="btn btn-secondary" onclick="closeLogin()">Cancel</button>
            </div>
            <div id="loginError" style="color: #dc3545; margin-top: 10px; display: none;"></div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container active" id="mainContainer">
        <div class="main-content">
            <h1>Restaurant Picker</h1>

            <div class="wheel-container">
                <div class="wheel-pointer"></div>
                <canvas id="wheelCanvas"></canvas>
            </div>

            <div class="controls">
                <button class="btn" id="spinBtn" onclick="spin()">Spin to Select</button>
            </div>

            <div class="result" id="result">
                <p style="color: #6c757d;">Select spin button to begin random selection</p>
            </div>
        </div>

        <div class="sidebar">
            <h3>Settings</h3>
            <div style="margin-bottom: 20px;">
                <button id="darkModeToggle" class="btn btn-small" onclick="toggleDarkMode()" style="width: 100%; margin-bottom: 10px;">
                    <span id="darkModeIcon">üåô</span> <span id="darkModeText">Dark Mode</span>
                </button>

                <button id="soundToggle" class="btn btn-small" onclick="toggleSound()" style="width: 100%; margin-bottom: 10px;">
                    <span id="soundIcon">üîä</span> <span id="soundText">Sound On</span>
                </button>

                <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                    <label for="wheelColorPicker" style="font-size: 0.9em; color: var(--text-secondary);">Wheel Color:</label>
                    <input type="color" id="wheelColorPicker" value="#667eea" onchange="updateWheelColor()" style="width: 50px; height: 30px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer;">
                    <button class="btn btn-small" onclick="resetWheelColor()" style="font-size: 0.8em; padding: 5px 10px;">Reset</button>
                </div>
            </div>

            <h3>Service Type <button class="btn-icon" onclick="showServiceWheel()" title="Spin to choose service type">üé°</button></h3>
            <div class="profile-section">
                <select id="serviceTypeSelector" onchange="onServiceTypeChange()">
                    <option value="all">All Service Types</option>
                    <option value="takeout">Takeout</option>
                    <option value="delivery">Delivery</option>
                    <option value="dine-in">Dine In</option>
                    <option value="at-home">At Home</option>
                </select>
            </div>

            <h3>Dining Profile</h3>
            <div class="profile-section">
                <div class="autocomplete-wrapper">
                    <input
                        type="text"
                        id="profileInput"
                        placeholder="Type to search profiles..."
                        autocomplete="off"
                        oninput="handleProfileInput()"
                        onfocus="handleProfileFocus()"
                        onblur="handleProfileBlur()"
                    >
                    <div id="profileSuggestions" class="autocomplete-suggestions"></div>
                </div>
            </div>

            <h3>Filter by Food Type</h3>
            <div class="filter-group" id="foodTypeFilters">
                <!-- Will be populated dynamically -->
            </div>

            <div class="admin-section">
                <div id="adminPanel" class="admin-panel">
                    <div id="unsavedChangesBanner" class="unsaved-changes-banner">
                        ‚ö†Ô∏è You have <span class="unsaved-changes-count" id="unsavedCount">0</span> unsaved change(s)
                    </div>

                    <h3>Manage Restaurants</h3>

                    <div class="form-group">
                        <label>Restaurant Name</label>
                        <input type="text" id="restaurantName" placeholder="Restaurant name">
                    </div>

                    <div class="form-group section-group">
                        <label>Food Types</label>
                        <div class="checkbox-group food-types-list">
                            <label><input type="checkbox" value="Barbecue" class="food-type-checkbox"> Barbecue</label>
                            <label><input type="checkbox" value="Breakfast & Brunch" class="food-type-checkbox"> Breakfast & Brunch</label>
                            <label><input type="checkbox" value="Chinese" class="food-type-checkbox"> Chinese</label>
                            <label><input type="checkbox" value="Diner & Grill" class="food-type-checkbox"> Diner & Grill</label>
                            <label><input type="checkbox" value="Ethiopian" class="food-type-checkbox"> Ethiopian</label>
                            <label><input type="checkbox" value="French" class="food-type-checkbox"> French</label>
                            <label><input type="checkbox" value="German" class="food-type-checkbox"> German</label>
                            <label><input type="checkbox" value="Indian" class="food-type-checkbox"> Indian</label>
                            <label><input type="checkbox" value="Italian" class="food-type-checkbox"> Italian</label>
                            <label><input type="checkbox" value="Japanese" class="food-type-checkbox"> Japanese</label>
                            <label><input type="checkbox" value="Korean" class="food-type-checkbox"> Korean</label>
                            <label><input type="checkbox" value="Mediterranean/Middle Eastern" class="food-type-checkbox"> Mediterranean/Middle Eastern</label>
                            <label><input type="checkbox" value="Mexican" class="food-type-checkbox"> Mexican</label>
                            <label><input type="checkbox" value="Pizza" class="food-type-checkbox"> Pizza</label>
                            <label><input type="checkbox" value="Plant-based" class="food-type-checkbox"> Plant-based</label>
                            <label><input type="checkbox" value="Somali" class="food-type-checkbox"> Somali</label>
                            <label><input type="checkbox" value="Thai" class="food-type-checkbox"> Thai</label>
                            <label><input type="checkbox" value="Vietnamese/Cambodian" class="food-type-checkbox"> Vietnamese/Cambodian</label>
                        </div>
                    </div>

                    <div class="form-group section-group">
                        <label>Service Types</label>
                        <div class="checkbox-group">
                            <label><input type="checkbox" value="takeout" class="service-type-checkbox"> Takeout</label>
                            <label><input type="checkbox" value="delivery" class="service-type-checkbox"> Delivery</label>
                            <label><input type="checkbox" value="dine-in" class="service-type-checkbox"> Dine In</label>
                            <label><input type="checkbox" value="at-home" class="service-type-checkbox"> At Home</label>
                        </div>
                    </div>

                    <div class="form-group section-group">
                        <label>Dining Profiles</label>
                        <div class="checkbox-group" id="restaurantProfileCheckboxes">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>

                    <div class="form-group">
                        <label>How to Order (optional)</label>
                        <input type="text" id="orderMethod" placeholder="e.g., DoorDash, call, online">
                    </div>

                    <div class="form-group">
                        <label>Menu Link (optional)</label>
                        <input type="text" id="menuLink" placeholder="https://restaurant.com/menu">
                    </div>

                    <div class="form-group">
                        <label>Address (optional)</label>
                        <input type="text" id="address" placeholder="123 Main St">
                    </div>

                    <div class="form-group">
                        <label>Phone (optional)</label>
                        <input type="text" id="phone" placeholder="(555) 123-4567">
                    </div>

                    <div class="form-group">
                        <label>Notes (optional)</label>
                        <textarea id="notes" placeholder="Any special notes about this restaurant" rows="3" style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 5px; font-family: inherit; resize: vertical;"></textarea>
                    </div>

                    <button class="btn btn-success btn-small" onclick="addRestaurant()">Add Restaurant</button>

                    <div class="restaurant-list" id="restaurantList">
                        <!-- Will be populated dynamically -->
                    </div>

                    <h3 style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #dee2e6;">Manage Profiles</h3>

                    <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 15px;">Profiles are assigned to restaurants above. Create profile names here, then tag restaurants with them.</p>

                    <div class="form-group">
                        <label>Profile Name</label>
                        <input type="text" id="profileName" placeholder="e.g., With Sarah">
                    </div>

                    <button class="btn btn-success btn-small" onclick="addProfile()">Add Profile</button>

                    <div class="restaurant-list" id="profileList" style="margin-top: 20px;">
                        <!-- Will be populated dynamically -->
                    </div>

                    <div id="saveActions" class="save-actions">
                        <button class="btn btn-success" onclick="saveAllChanges()">üíæ Save All Changes</button>
                        <button class="btn btn-danger" onclick="discardChanges()">üóëÔ∏è Discard Changes</button>
                    </div>

                    <h3 style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #dee2e6;">Bulk Edit</h3>

                    <div id="bulkEditSection" style="margin-top: 15px;">
                        <div style="margin-bottom: 15px;">
                            <button class="btn btn-small" onclick="toggleBulkSelectAll()" style="margin-bottom: 10px;">Select All / None</button>
                            <div id="bulkRestaurantList" style="max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; background: var(--input-bg);">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>

                        <div id="bulkEditActions" style="display: none;">
                            <div class="form-group">
                                <label>Bulk Action</label>
                                <select id="bulkActionType" onchange="updateBulkActionInputs()">
                                    <option value="">-- Select Action --</option>
                                    <option value="add-profile">Add to Profile</option>
                                    <option value="remove-profile">Remove from Profile</option>
                                    <option value="add-food-type">Add Food Type</option>
                                    <option value="remove-food-type">Remove Food Type</option>
                                    <option value="add-service-type">Add Service Type</option>
                                    <option value="remove-service-type">Remove Service Type</option>
                                </select>
                            </div>

                            <div id="bulkActionInputs"></div>

                            <button class="btn btn-success btn-small" onclick="applyBulkEdit()" style="margin-top: 10px;">Apply to Selected</button>
                        </div>
                    </div>

                    <h3 style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #dee2e6;">Data Management</h3>

                    <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                        <button class="btn btn-small" onclick="exportData()">üì• Export Data</button>
                        <button class="btn btn-small" onclick="document.getElementById('importFile').click()">üì§ Import Data</button>
                        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
                    </div>

                    <button class="btn btn-secondary btn-small" onclick="logout()" style="margin-top: 20px;">Logout</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let restaurants = [];
        let profiles = [];
        let selectedProfile = 'all';
        let selectedService = 'all';
        let currentRotation = 0;
        let isSpinning = false;
        let isAuthenticated = false;
        let authToken = null;

        // Batch save system - local working copies
        let localRestaurants = [];
        let localProfiles = [];
        let pendingChanges = {
            addedRestaurants: [],
            deletedRestaurants: [],
            addedProfiles: [],
            deletedProfiles: []
        };
        let hasUnsavedChanges = false;

        // Configuration constants
        const CONFIG = {
            WHEEL_COLORS: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#95E1D3'],
            MIN_SPINS: 5,
            MAX_SPINS: 8,
            SPIN_DURATION: 4000, // milliseconds
            CACHE_MAX_AGE: 60 // seconds
        };

        // Canvas and wheel variables
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const colors = CONFIG.WHEEL_COLORS;

        /**
         * Sanitize HTML to prevent XSS attacks
         * Escapes special characters that could be interpreted as HTML
         * @param {string} str - String to sanitize
         * @returns {string} - Sanitized string safe for HTML insertion
         */
        function sanitizeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        /**
         * Validate URL format
         * @param {string} url - URL to validate
         * @returns {boolean} - Whether URL is valid
         */
        function isValidURL(url) {
            if (!url) return false;
            try {
                new URL(url);
                return true;
            } catch {
                return false;
            }
        }

        /**
         * Toggle dark mode
         */
        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');

            // Update button text and icon
            const icon = document.getElementById('darkModeIcon');
            const text = document.getElementById('darkModeText');
            if (isDark) {
                icon.textContent = '‚òÄÔ∏è';
                text.textContent = 'Light Mode';
            } else {
                icon.textContent = 'üåô';
                text.textContent = 'Dark Mode';
            }

            // Redraw wheels to match theme
            drawWheel();
            if (document.getElementById('serviceWheelCanvas')) {
                drawServiceWheel();
            }
        }

        /**
         * Initialize dark mode from localStorage
         */
        function initDarkMode() {
            const darkMode = localStorage.getItem('darkMode');
            if (darkMode === 'enabled') {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeIcon').textContent = '‚òÄÔ∏è';
                document.getElementById('darkModeText').textContent = 'Light Mode';
            }
        }

        /**
         * Sound effects state and functions
         */
        let soundEnabled = true;
        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSpinSound() {
            if (!soundEnabled) return;
            initAudioContext();

            // Create a quick ascending tone
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playWinSound() {
            if (!soundEnabled) return;
            initAudioContext();

            // Create a celebratory ascending arpeggio
            const notes = [261.63, 329.63, 392.00, 523.25]; // C, E, G, C (major chord)
            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                const startTime = audioContext.currentTime + (index * 0.1);
                oscillator.frequency.setValueAtTime(freq, startTime);

                gainNode.gain.setValueAtTime(0.2, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                oscillator.start(startTime);
                oscillator.stop(startTime + 0.3);
            });
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled ? 'enabled' : 'disabled');

            const icon = document.getElementById('soundIcon');
            const text = document.getElementById('soundText');
            if (soundEnabled) {
                icon.textContent = 'üîä';
                text.textContent = 'Sound On';
                playWinSound(); // Play test sound
            } else {
                icon.textContent = 'üîá';
                text.textContent = 'Sound Off';
            }
        }

        function initSound() {
            const sound = localStorage.getItem('soundEnabled');
            if (sound === 'disabled') {
                soundEnabled = false;
                document.getElementById('soundIcon').textContent = 'üîá';
                document.getElementById('soundText').textContent = 'Sound Off';
            }
        }

        /**
         * Custom wheel color functions
         */
        let customWheelColor = null;

        function updateWheelColor() {
            const picker = document.getElementById('wheelColorPicker');
            customWheelColor = picker.value;
            localStorage.setItem('wheelColor', customWheelColor);
            drawWheel();
        }

        function resetWheelColor() {
            customWheelColor = null;
            localStorage.removeItem('wheelColor');
            document.getElementById('wheelColorPicker').value = '#667eea';
            drawWheel();
        }

        function initWheelColor() {
            const savedColor = localStorage.getItem('wheelColor');
            if (savedColor) {
                customWheelColor = savedColor;
                document.getElementById('wheelColorPicker').value = savedColor;
            }
        }

        function getWheelColors() {
            if (customWheelColor) {
                // Generate shades of the custom color
                return Array.from({ length: 10 }, (_, i) => {
                    const lightness = 50 + (i % 2 === 0 ? 10 : -10);
                    return adjustColorLightness(customWheelColor, lightness);
                });
            }
            return CONFIG.WHEEL_COLORS;
        }

        function adjustColorLightness(hex, lightness) {
            // Convert hex to RGB
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);

            // Adjust lightness
            const factor = lightness / 50;
            const newR = Math.min(255, Math.max(0, Math.round(r * factor)));
            const newG = Math.min(255, Math.max(0, Math.round(g * factor)));
            const newB = Math.min(255, Math.max(0, Math.round(b * factor)));

            // Convert back to hex
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        /**
         * Load profile from URL path
         * Checks the pathname (e.g., /work) and auto-selects that profile if it exists
         */
        function loadProfileFromURL() {
            const pathname = window.location.pathname;

            // Remove leading and trailing slashes, get the first path segment
            const pathSegments = pathname.split('/').filter(segment => segment.length > 0);

            if (pathSegments.length === 0) {
                // No path segment, stay on 'all' profile
                return;
            }

            const profileId = pathSegments[0];

            // Check if this profile exists
            const profile = profiles.find(p => p.id === profileId);

            if (profile) {
                // Auto-select this profile
                selectedProfile = profile.id;
                updateProfileInput();

                // Update page title to show the profile
                document.title = `Restaurant Picker - ${profile.name}`;
            }
            // If profile doesn't exist, just stay on default 'all' profile
        }

        // Initialize
        async function init() {
            initDarkMode(); // Load dark mode preference first
            initSound(); // Load sound preference
            initWheelColor(); // Load wheel color preference
            await loadRestaurants();
            loadProfileFromURL(); // Load profile from URL if present
            updateProfileInput();
            updateFoodTypeFilters();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            initServiceWheel();

            // Handle browser back/forward buttons
            window.addEventListener('popstate', (e) => {
                loadProfileFromURL();
                drawWheel();
            });

            // Warn before leaving with unsaved changes
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges) {
                    e.preventDefault();
                    e.returnValue = ''; // Required for Chrome
                }
            });
        }

        // Service Type Wheel Functions
        let serviceWheelRotation = 0;
        let isServiceWheelSpinning = false;
        const serviceTypes = [
            { id: 'takeout', name: 'Takeout', color: '#FF6B6B' },
            { id: 'delivery', name: 'Delivery', color: '#4ECDC4' },
            { id: 'dine-in', name: 'Dine In', color: '#45B7D1' },
            { id: 'at-home', name: 'At Home', color: '#F7DC6F' }
        ];

        function initServiceWheel() {
            const canvas = document.getElementById('serviceWheelCanvas');
            const container = document.querySelector('.service-wheel-container');
            if (!canvas || !container) return;

            const size = Math.min(container.offsetWidth, container.offsetHeight);
            canvas.width = size;
            canvas.height = size;
            drawServiceWheel();
        }

        function showServiceWheel() {
            document.getElementById('serviceWheelModal').classList.add('active');
            document.getElementById('serviceResult').textContent = '';
            initServiceWheel();
        }

        function closeServiceWheel() {
            document.getElementById('serviceWheelModal').classList.remove('active');
        }

        function drawServiceWheel() {
            const canvas = document.getElementById('serviceWheelCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const numSegments = serviceTypes.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            serviceTypes.forEach((type, i) => {
                const startAngle = i * anglePerSegment + serviceWheelRotation;
                const endAngle = (i + 1) * anglePerSegment + serviceWheelRotation;

                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = type.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + anglePerSegment / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(type.name, radius - 15, 5);
                ctx.restore();
            });

            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function spinServiceWheel() {
            if (isServiceWheelSpinning) return;

            isServiceWheelSpinning = true;
            document.getElementById('spinServiceBtn').disabled = true;
            document.getElementById('serviceResult').textContent = '';

            const numSegments = serviceTypes.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;

            // Random spin
            const spins = 3 + Math.random() * 3; // 3-6 spins
            const randomAngle = Math.random() * 2 * Math.PI;
            const totalRotation = spins * 2 * Math.PI + randomAngle;

            const duration = 3000; // 3 seconds
            const startTime = Date.now();
            const startRotation = serviceWheelRotation;

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function (ease out)
                const easeOut = 1 - Math.pow(1 - progress, 3);

                serviceWheelRotation = startRotation + totalRotation * easeOut;
                drawServiceWheel();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isServiceWheelSpinning = false;
                    document.getElementById('spinServiceBtn').disabled = false;
                    showServiceResult(numSegments, anglePerSegment);
                }
            }

            animate();
        }

        function showServiceResult(numSegments, anglePerSegment) {
            const normalizedRotation = (serviceWheelRotation % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            const pointerAngle = 3 * Math.PI / 2; // Pointer is at top (270 degrees in canvas coords)
            const selectedAngle = (2 * Math.PI - normalizedRotation + pointerAngle) % (2 * Math.PI);
            const selectedIndex = Math.floor(selectedAngle / anglePerSegment) % numSegments;
            const selectedType = serviceTypes[selectedIndex];

            document.getElementById('serviceResult').textContent = `üéâ ${selectedType.name}!`;

            // Update the dropdown to match
            selectedService = selectedType.id;
            document.getElementById('serviceTypeSelector').value = selectedType.id;

            // Update the main wheel after a short delay
            setTimeout(() => {
                drawWheel();
                closeServiceWheel();
            }, 2000);
        }

        // Configuration for deployment mode
        let isStaticMode = false; // Will be set to true if API is not available

        /**
         * Load restaurants from API or static JSON file
         * Tries to load from /api/restaurants (Cloudflare Functions)
         * Falls back to /restaurants.json (static deployment) if API is unavailable
         */
        async function loadRestaurants() {
            try {
                // First, try to load from API (Cloudflare Functions)
                const response = await fetch('/api/restaurants');
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                const data = await response.json();
                restaurants = data.restaurants || [];
                profiles = data.profiles || [{id: 'all', name: 'All Restaurants'}];
                isStaticMode = false; // API is available
            } catch (apiError) {
                console.log('API not available, trying static JSON file...', apiError);

                try {
                    // Fallback to static JSON file
                    const response = await fetch('/restaurants.json');
                    if (!response.ok) {
                        throw new Error(`Static JSON file returned ${response.status}`);
                    }
                    const data = await response.json();
                    restaurants = data.restaurants || [];
                    profiles = data.profiles || [{id: 'all', name: 'All Restaurants'}];
                    isStaticMode = true; // Running in static mode
                    console.log('Loaded data from static JSON file (static deployment mode)');
                } catch (staticError) {
                    console.error('Error loading from both API and static file:', staticError);

                    // Final fallback to hardcoded demo data
                    restaurants = [
                        {id: 1, name: "Mario's Italian Bistro", foodTypes: ["Italian", "Pizza"], serviceTypes: ["takeout", "delivery", "dine-in"], profiles: [], orderMethod: "Call or DoorDash", menuLink: "", notes: ""},
                        {id: 2, name: "Golden Dragon", foodTypes: ["Chinese", "Asian"], serviceTypes: ["takeout", "delivery"], profiles: [], orderMethod: "Phone", menuLink: "", notes: ""},
                        {id: 3, name: "Taco Fiesta", foodTypes: ["Mexican", "Latin"], serviceTypes: ["takeout", "dine-in"], profiles: [], orderMethod: "Call ahead", menuLink: "", notes: ""},
                        {id: 4, name: "Burger Palace", foodTypes: ["American", "Burgers"], serviceTypes: ["takeout", "delivery", "dine-in"], profiles: [], orderMethod: "Call or app", menuLink: "", notes: ""},
                        {id: 5, name: "Sushi Paradise", foodTypes: ["Japanese", "Asian", "Sushi"], serviceTypes: ["takeout", "delivery", "dine-in"], profiles: [], orderMethod: "Call or online", menuLink: "", notes: ""}
                    ];
                    profiles = [{id: 'all', name: 'All Restaurants'}];
                    isStaticMode = true;

                    // Hide admin login button
                    const adminBtn = document.getElementById('adminBtn');
                    if (adminBtn) {
                        adminBtn.style.display = 'none';
                    }
                }
            }

            // Initialize local working copies
            localRestaurants = JSON.parse(JSON.stringify(restaurants));
            localProfiles = JSON.parse(JSON.stringify(profiles));

            // Reset pending changes
            pendingChanges = {
                addedRestaurants: [],
                deletedRestaurants: [],
                addedProfiles: [],
                deletedProfiles: []
            };
            hasUnsavedChanges = false;
            updateUnsavedChangesUI();
        }

        /**
         * Update the unsaved changes UI (banner and save buttons)
         */
        function updateUnsavedChangesUI() {
            const changeCount = pendingChanges.addedRestaurants.length +
                                pendingChanges.deletedRestaurants.length +
                                pendingChanges.addedProfiles.length +
                                pendingChanges.deletedProfiles.length;

            hasUnsavedChanges = changeCount > 0;

            const banner = document.getElementById('unsavedChangesBanner');
            const saveActions = document.getElementById('saveActions');
            const countElem = document.getElementById('unsavedCount');

            if (hasUnsavedChanges) {
                banner.classList.add('active');
                saveActions.classList.add('active');
                countElem.textContent = changeCount;
            } else {
                banner.classList.remove('active');
                saveActions.classList.remove('active');
            }
        }

        /**
         * Discard all unsaved changes and reload from server
         */
        async function discardChanges() {
            if (!confirm('Are you sure you want to discard all unsaved changes?')) {
                return;
            }

            await loadRestaurants();
            updateFoodTypeFilters();
            updateRestaurantList();
            updateProfileInput();
            updateProfileList();
            drawWheel();
        }

        /**
         * Save all pending changes to GitHub in a single commit
         */
        async function saveAllChanges() {
            if (!hasUnsavedChanges) {
                alert('No changes to save');
                return;
            }

            if (!confirm(`Save ${pendingChanges.addedRestaurants.length + pendingChanges.deletedRestaurants.length + pendingChanges.addedProfiles.length + pendingChanges.deletedProfiles.length} change(s) to GitHub?`)) {
                return;
            }

            try {
                // Process all deletions first
                for (const id of pendingChanges.deletedRestaurants) {
                    await fetch(`/api/restaurants/${id}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                }

                for (const id of pendingChanges.deletedProfiles) {
                    await fetch(`/api/profiles/${id}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                }

                // Then process additions
                for (const restaurant of pendingChanges.addedRestaurants) {
                    await fetch('/api/restaurants', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(restaurant)
                    });
                }

                for (const profile of pendingChanges.addedProfiles) {
                    await fetch('/api/profiles', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(profile)
                    });
                }

                // Reload from server to get fresh data
                await loadRestaurants();
                updateFoodTypeFilters();
                updateRestaurantList();
                updateProfileInput();
                updateProfileList();
                drawWheel();

                alert('All changes saved successfully!');
            } catch (error) {
                console.error('Error saving changes:', error);
                alert('Failed to save some changes. Please try again.');
            }
        }

        /**
         * Bulk Edit Functions
         */
        let selectedBulkRestaurants = new Set();

        function updateBulkRestaurantList() {
            const container = document.getElementById('bulkRestaurantList');
            if (!container) return;

            if (localRestaurants.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); margin: 0;">No restaurants available</p>';
                return;
            }

            let html = '';
            localRestaurants.forEach(r => {
                const checked = selectedBulkRestaurants.has(r.id) ? 'checked' : '';
                html += `
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" value="${r.id}" onchange="toggleBulkRestaurant(${r.id})" ${checked}>
                        <span style="margin-left: 8px;">${sanitizeHTML(r.name)}</span>
                    </label>
                `;
            });
            container.innerHTML = html;
        }

        function toggleBulkRestaurant(id) {
            if (selectedBulkRestaurants.has(id)) {
                selectedBulkRestaurants.delete(id);
            } else {
                selectedBulkRestaurants.add(id);
            }

            const actionsDiv = document.getElementById('bulkEditActions');
            if (selectedBulkRestaurants.size > 0) {
                actionsDiv.style.display = 'block';
            } else {
                actionsDiv.style.display = 'none';
            }
        }

        function toggleBulkSelectAll() {
            if (selectedBulkRestaurants.size === localRestaurants.length) {
                selectedBulkRestaurants.clear();
            } else {
                localRestaurants.forEach(r => selectedBulkRestaurants.add(r.id));
            }
            updateBulkRestaurantList();

            const actionsDiv = document.getElementById('bulkEditActions');
            if (selectedBulkRestaurants.size > 0) {
                actionsDiv.style.display = 'block';
            } else {
                actionsDiv.style.display = 'none';
            }
        }

        function updateBulkActionInputs() {
            const actionType = document.getElementById('bulkActionType').value;
            const inputsDiv = document.getElementById('bulkActionInputs');

            if (!actionType) {
                inputsDiv.innerHTML = '';
                return;
            }

            let html = '<div class="form-group">';

            if (actionType === 'add-profile' || actionType === 'remove-profile') {
                html += `
                    <label>Select Profile</label>
                    <select id="bulkActionValue">
                        ${localProfiles.filter(p => p.id !== 'all').map(p =>
                            `<option value="${p.id}">${sanitizeHTML(p.name)}</option>`
                        ).join('')}
                    </select>
                `;
            } else if (actionType === 'add-food-type' || actionType === 'remove-food-type') {
                const foodTypes = ['Barbecue', 'Breakfast & Brunch', 'Burgers', 'Chinese', 'Comfort Food',
                                   'Desserts & Bakeries', 'Fast Food', 'Indian', 'Italian', 'Japanese',
                                   'Mediterranean/Middle Eastern', 'Mexican', 'Pizza', 'Sandwiches & Delis',
                                   'Seafood', 'Thai', 'Vegan/Vegetarian', 'Vietnamese/Cambodian'];
                html += `
                    <label>Select Food Type</label>
                    <select id="bulkActionValue">
                        ${foodTypes.map(ft => `<option value="${ft}">${ft}</option>`).join('')}
                    </select>
                `;
            } else if (actionType === 'add-service-type' || actionType === 'remove-service-type') {
                html += `
                    <label>Select Service Type</label>
                    <select id="bulkActionValue">
                        <option value="takeout">Takeout</option>
                        <option value="delivery">Delivery</option>
                        <option value="dine-in">Dine In</option>
                        <option value="at-home">At Home</option>
                    </select>
                `;
            }

            html += '</div>';
            inputsDiv.innerHTML = html;
        }

        function applyBulkEdit() {
            const actionType = document.getElementById('bulkActionType').value;
            const actionValue = document.getElementById('bulkActionValue')?.value;

            if (!actionType) {
                alert('Please select a bulk action');
                return;
            }

            if (!actionValue) {
                alert('Please select a value for the action');
                return;
            }

            let changedCount = 0;

            selectedBulkRestaurants.forEach(id => {
                const restaurant = localRestaurants.find(r => r.id === id);
                if (!restaurant) return;

                let changed = false;

                if (actionType === 'add-profile') {
                    if (!restaurant.profiles) restaurant.profiles = [];
                    if (!restaurant.profiles.includes(actionValue)) {
                        restaurant.profiles.push(actionValue);
                        changed = true;
                    }
                } else if (actionType === 'remove-profile') {
                    if (restaurant.profiles) {
                        const index = restaurant.profiles.indexOf(actionValue);
                        if (index > -1) {
                            restaurant.profiles.splice(index, 1);
                            changed = true;
                        }
                    }
                } else if (actionType === 'add-food-type') {
                    if (!restaurant.foodTypes) restaurant.foodTypes = [];
                    if (!restaurant.foodTypes.includes(actionValue)) {
                        restaurant.foodTypes.push(actionValue);
                        changed = true;
                    }
                } else if (actionType === 'remove-food-type') {
                    if (restaurant.foodTypes) {
                        const index = restaurant.foodTypes.indexOf(actionValue);
                        if (index > -1) {
                            restaurant.foodTypes.splice(index, 1);
                            changed = true;
                        }
                    }
                } else if (actionType === 'add-service-type') {
                    if (!restaurant.serviceTypes) restaurant.serviceTypes = [];
                    if (!restaurant.serviceTypes.includes(actionValue)) {
                        restaurant.serviceTypes.push(actionValue);
                        changed = true;
                    }
                } else if (actionType === 'remove-service-type') {
                    if (restaurant.serviceTypes) {
                        const index = restaurant.serviceTypes.indexOf(actionValue);
                        if (index > -1) {
                            restaurant.serviceTypes.splice(index, 1);
                            changed = true;
                        }
                    }
                }

                if (changed) {
                    changedCount++;
                    // Mark as changed if not already in pending
                    if (!pendingChanges.addedRestaurants.find(r => r.id === id)) {
                        pendingChanges.addedRestaurants.push(restaurant);
                    }
                }
            });

            if (changedCount > 0) {
                restaurants = JSON.parse(JSON.stringify(localRestaurants));
                updateFoodTypeFilters();
                updateRestaurantList();
                updateBulkRestaurantList();
                updateUnsavedChangesUI();
                drawWheel();
                alert(`Bulk edit applied to ${changedCount} restaurant(s). Remember to save changes!`);
            } else {
                alert('No changes were made. The selected restaurants may already have this attribute.');
            }

            // Clear selections and reset
            selectedBulkRestaurants.clear();
            updateBulkRestaurantList();
            document.getElementById('bulkActionType').value = '';
            document.getElementById('bulkActionInputs').innerHTML = '';
            document.getElementById('bulkEditActions').style.display = 'none';
        }

        /**
         * Handle service type selector change
         * Updates selected service type and redraws wheel with filtered restaurants
         */
        function onServiceTypeChange() {
            selectedService = document.getElementById('serviceTypeSelector').value;
            drawWheel();
        }

        // Profile management
        /**
         * Update the profile input field to show the current selection
         */
        function updateProfileInput() {
            const input = document.getElementById('profileInput');
            const currentProfile = profiles.find(p => p.id === selectedProfile);
            if (currentProfile) {
                input.value = currentProfile.name;
            }
        }

        /**
         * Handle input changes in the profile autocomplete field
         * Shows filtered suggestions based on user input
         */
        function handleProfileInput() {
            const input = document.getElementById('profileInput');
            const suggestionsContainer = document.getElementById('profileSuggestions');
            const searchTerm = input.value.toLowerCase().trim();

            // Filter profiles based on search term
            const filteredProfiles = profiles.filter(profile =>
                profile.name.toLowerCase().includes(searchTerm)
            );

            // Clear and populate suggestions
            suggestionsContainer.innerHTML = '';

            if (searchTerm === '' || filteredProfiles.length === 0) {
                suggestionsContainer.classList.remove('active');
                return;
            }

            filteredProfiles.forEach(profile => {
                const div = document.createElement('div');
                div.className = 'autocomplete-suggestion';
                if (profile.id === selectedProfile) {
                    div.classList.add('selected');
                }
                div.textContent = profile.name;
                div.onclick = () => selectProfile(profile.id, profile.name);
                suggestionsContainer.appendChild(div);
            });

            suggestionsContainer.classList.add('active');
        }

        /**
         * Handle focus on the profile input field
         * Shows all available profiles
         */
        function handleProfileFocus() {
            const input = document.getElementById('profileInput');
            const suggestionsContainer = document.getElementById('profileSuggestions');

            // Show all profiles when focused
            suggestionsContainer.innerHTML = '';

            profiles.forEach(profile => {
                const div = document.createElement('div');
                div.className = 'autocomplete-suggestion';
                if (profile.id === selectedProfile) {
                    div.classList.add('selected');
                }
                div.textContent = profile.name;
                div.onclick = () => selectProfile(profile.id, profile.name);
                suggestionsContainer.appendChild(div);
            });

            suggestionsContainer.classList.add('active');
        }

        /**
         * Handle blur event on the profile input field
         * Hides suggestions after a short delay (to allow click events to fire)
         */
        function handleProfileBlur() {
            setTimeout(() => {
                const suggestionsContainer = document.getElementById('profileSuggestions');
                suggestionsContainer.classList.remove('active');
            }, 200);
        }

        /**
         * Select a profile from the autocomplete suggestions
         * Updates the URL to reflect the selected profile
         * @param {string} profileId - The ID of the selected profile
         * @param {string} profileName - The display name of the selected profile
         */
        function selectProfile(profileId, profileName) {
            selectedProfile = profileId;
            const input = document.getElementById('profileInput');
            input.value = profileName;
            const suggestionsContainer = document.getElementById('profileSuggestions');
            suggestionsContainer.classList.remove('active');

            // Update URL to reflect the selected profile
            const newPath = profileId === 'all' ? '/' : `/${profileId}`;
            window.history.pushState({ profileId }, '', newPath);

            // Update page title
            const newTitle = profileId === 'all' ? 'Restaurant Picker' : `Restaurant Picker - ${profileName}`;
            document.title = newTitle;

            drawWheel();
        }

        /**
         * Get filtered restaurants based on current filter selections
         * @returns {Array} - Filtered array of restaurant objects
         */
        function getFilteredRestaurants() {
            const selectedFoodTypes = Array.from(document.querySelectorAll('#foodTypeFilters input:checked'))
                .map(cb => cb.value);

            return restaurants.filter(r => {
                // Filter by profile (if specific profile selected)
                // "all" profile shows all restaurants, otherwise check if restaurant has the profile tag
                if (selectedProfile !== 'all') {
                    if (!r.profiles || !r.profiles.includes(selectedProfile)) {
                        return false;
                    }
                }

                // Filter by service type
                // "all" shows all service types, otherwise check if restaurant offers the selected service type
                if (selectedService !== 'all') {
                    if (!r.serviceTypes || !r.serviceTypes.includes(selectedService)) {
                        return false;
                    }
                }

                // Filter by food types (if any are selected)
                if (selectedFoodTypes.length > 0) {
                    return r.foodTypes.some(ft => selectedFoodTypes.includes(ft));
                }

                return true;
            });
        }

        // Update food type filters
        function updateFoodTypeFilters() {
            const allFoodTypes = new Set();
            restaurants.forEach(r => {
                r.foodTypes.forEach(ft => allFoodTypes.add(ft));
            });

            const container = document.getElementById('foodTypeFilters');
            container.innerHTML = '';

            Array.from(allFoodTypes).sort().forEach(foodType => {
                const label = document.createElement('label');
                label.innerHTML = `
                    <input type="checkbox" value="${foodType}" onchange="drawWheel()">
                    ${foodType}
                `;
                container.appendChild(label);
            });
        }

        // Canvas setup
        function resizeCanvas() {
            const container = document.querySelector('.wheel-container');
            const size = Math.min(container.offsetWidth, container.offsetHeight);
            canvas.width = size;
            canvas.height = size;
            drawWheel();
        }

        // Draw the wheel
        function drawWheel() {
            const filteredRestaurants = getFilteredRestaurants();

            if (filteredRestaurants.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f8f9fa';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = '#6c757d';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No restaurants available', canvas.width / 2, canvas.height / 2);
                return;
            }

            const numSegments = filteredRestaurants.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const wheelColors = getWheelColors();
            filteredRestaurants.forEach((restaurant, i) => {
                const startAngle = i * anglePerSegment + currentRotation;
                const endAngle = (i + 1) * anglePerSegment + currentRotation;

                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = wheelColors[i % wheelColors.length];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + anglePerSegment / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(restaurant.name, radius - 20, 5);
                ctx.restore();
            });

            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 30, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // Spin the wheel
        function spin() {
            if (isSpinning) return;

            const filteredRestaurants = getFilteredRestaurants();
            if (filteredRestaurants.length === 0) {
                alert('No restaurants available with current filters!');
                return;
            }

            playSpinSound(); // Play spin sound effect

            isSpinning = true;
            document.getElementById('spinBtn').disabled = true;

            const numSegments = filteredRestaurants.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;

            // Random spin calculation using configuration constants
            const spins = CONFIG.MIN_SPINS + Math.random() * (CONFIG.MAX_SPINS - CONFIG.MIN_SPINS);
            const randomAngle = Math.random() * 2 * Math.PI;
            const totalRotation = spins * 2 * Math.PI + randomAngle;

            const duration = CONFIG.SPIN_DURATION;
            const startTime = Date.now();
            const startRotation = currentRotation;

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function (ease out)
                const easeOut = 1 - Math.pow(1 - progress, 3);

                currentRotation = startRotation + totalRotation * easeOut;
                drawWheel();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isSpinning = false;
                    document.getElementById('spinBtn').disabled = false;
                    showResult(filteredRestaurants, numSegments, anglePerSegment);
                }
            }

            animate();
        }

        /**
         * Trigger confetti animation
         */
        function triggerConfetti() {
            const duration = 3000;
            const animationEnd = Date.now() + duration;
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#F7DC6F', '#98D8C8', '#BB8FCE'];

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const confettiInterval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    clearInterval(confettiInterval);
                    return;
                }

                const particleCount = 3;

                for (let i = 0; i < particleCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.top = '-10px';
                    confetti.style.opacity = '1';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    confetti.style.zIndex = '10000';
                    confetti.style.pointerEvents = 'none';
                    confetti.style.borderRadius = '2px';

                    document.body.appendChild(confetti);

                    const duration = randomInRange(1000, 3000);
                    const xMovement = randomInRange(-100, 100);
                    const rotation = randomInRange(0, 720);

                    confetti.animate([
                        {
                            transform: `translateY(0) translateX(0) rotate(0deg)`,
                            opacity: 1
                        },
                        {
                            transform: `translateY(${window.innerHeight}px) translateX(${xMovement}px) rotate(${rotation}deg)`,
                            opacity: 0
                        }
                    ], {
                        duration: duration,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    }).onfinish = () => confetti.remove();
                }
            }, 50);
        }

        /**
         * Display selected restaurant result with sanitized content
         * @param {Array} filteredRestaurants - Array of filtered restaurant objects
         * @param {number} numSegments - Number of wheel segments
         * @param {number} anglePerSegment - Angle per segment in radians
         */
        function showResult(filteredRestaurants, numSegments, anglePerSegment) {
            const normalizedRotation = (currentRotation % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
            const pointerAngle = 3 * Math.PI / 2; // Pointer is at top (270 degrees in canvas coords)
            const selectedAngle = (2 * Math.PI - normalizedRotation + pointerAngle) % (2 * Math.PI);
            const selectedIndex = Math.floor(selectedAngle / anglePerSegment) % numSegments;
            const winner = filteredRestaurants[selectedIndex];

            // Trigger confetti animation and play win sound
            triggerConfetti();
            playWinSound();

            const resultDiv = document.getElementById('result');

            // Build result HTML with sanitized content to prevent XSS
            let html = `<h2>Selected: ${sanitizeHTML(winner.name)}</h2>`;
            html += `<p><strong>Food Types:</strong> ${winner.foodTypes.map(ft => sanitizeHTML(ft)).join(', ')}</p>`;

            if (winner.orderMethod) {
                html += `<p><strong>How to Order:</strong> ${sanitizeHTML(winner.orderMethod)}</p>`;
            }

            if (winner.menuLink && isValidURL(winner.menuLink)) {
                html += `<p><strong>Menu:</strong> <a href="${sanitizeHTML(winner.menuLink)}" target="_blank" rel="noopener noreferrer">View Menu</a></p>`;
            }

            if (winner.address) {
                html += `<p><strong>Address:</strong> ${sanitizeHTML(winner.address)}</p>`;
            }

            if (winner.phone) {
                html += `<p><strong>Phone:</strong> ${sanitizeHTML(winner.phone)}</p>`;
            }

            if (winner.notes) {
                html += `<p><strong>Notes:</strong> ${sanitizeHTML(winner.notes)}</p>`;
            }

            resultDiv.innerHTML = html;
        }

        // Authentication
        function showLogin() {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('adminPassword').value = '';
            document.getElementById('loginError').style.display = 'none';
        }

        function closeLogin() {
            document.getElementById('loginModal').classList.remove('active');
        }

        async function login() {
            const password = document.getElementById('adminPassword').value;

            try {
                const response = await fetch('/api/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ password })
                });

                const data = await response.json();

                if (data.authenticated) {
                    isAuthenticated = true;
                    authToken = data.token;
                    document.getElementById('loginModal').classList.remove('active');
                    document.getElementById('adminPanel').classList.add('active');
                    updateRestaurantList();
                    updateProfileList();
                } else {
                    document.getElementById('loginError').textContent = 'Invalid password';
                    document.getElementById('loginError').style.display = 'block';
                }
            } catch (error) {
                console.error('Login error:', error);
                document.getElementById('loginError').textContent = 'Login failed';
                document.getElementById('loginError').style.display = 'block';
            }
        }

        function logout() {
            isAuthenticated = false;
            authToken = null;
            document.getElementById('adminPanel').classList.remove('active');
        }

        // Add restaurant (to local state)
        function addRestaurant() {
            const name = document.getElementById('restaurantName').value.trim();
            const orderMethod = document.getElementById('orderMethod').value.trim();
            const menuLink = document.getElementById('menuLink').value.trim();
            const address = document.getElementById('address').value.trim();
            const phone = document.getElementById('phone').value.trim();
            const notes = document.getElementById('notes').value.trim();

            const foodTypes = Array.from(document.querySelectorAll('.food-type-checkbox:checked'))
                .map(cb => cb.value);

            const serviceTypes = Array.from(document.querySelectorAll('.service-type-checkbox:checked'))
                .map(cb => cb.value);

            const selectedProfiles = Array.from(document.querySelectorAll('.restaurant-profile-checkbox:checked'))
                .map(cb => cb.value);

            if (!name || foodTypes.length === 0 || serviceTypes.length === 0) {
                alert('Please fill in name, at least one food type, and at least one service type');
                return;
            }

            const newRestaurant = {
                id: Math.max(...localRestaurants.map(r => r.id), 0) + 1,
                name,
                foodTypes,
                serviceTypes,
                profiles: selectedProfiles,
                orderMethod,
                menuLink,
                address,
                phone,
                notes
            };

            // Add to local state and pending changes
            localRestaurants.push(newRestaurant);
            pendingChanges.addedRestaurants.push(newRestaurant);

            // Update UI to show local changes
            restaurants = JSON.parse(JSON.stringify(localRestaurants));
            updateFoodTypeFilters();
            updateRestaurantList();
            updateUnsavedChangesUI();
            drawWheel();

            // Clear form
            document.getElementById('restaurantName').value = '';
            document.getElementById('orderMethod').value = '';
            document.getElementById('menuLink').value = '';
            document.getElementById('address').value = '';
            document.getElementById('phone').value = '';
            document.getElementById('notes').value = '';
            document.querySelectorAll('.food-type-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.service-type-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.restaurant-profile-checkbox').forEach(cb => cb.checked = false);
        }

        // Delete restaurant (from local state)
        function deleteRestaurant(id) {
            if (!confirm('Are you sure you want to delete this restaurant?')) {
                return;
            }

            // Remove from local state
            const index = localRestaurants.findIndex(r => r.id === id);
            if (index !== -1) {
                localRestaurants.splice(index, 1);
            }

            // Track deletion
            pendingChanges.deletedRestaurants.push(id);

            // Update UI to show local changes
            restaurants = JSON.parse(JSON.stringify(localRestaurants));
            updateFoodTypeFilters();
            updateRestaurantList();
            updateUnsavedChangesUI();
            drawWheel();
        }

        // Duplicate restaurant (creates copy in local state)
        function duplicateRestaurant(id) {
            const original = localRestaurants.find(r => r.id === id);
            if (!original) return;

            const duplicate = {
                ...original,
                id: Math.max(...localRestaurants.map(r => r.id), 0) + 1,
                name: `${original.name} (Copy)`,
                // Deep copy arrays
                foodTypes: [...original.foodTypes],
                serviceTypes: [...original.serviceTypes],
                profiles: [...(original.profiles || [])]
            };

            // Add to local state and pending changes
            localRestaurants.push(duplicate);
            pendingChanges.addedRestaurants.push(duplicate);

            // Update UI
            restaurants = JSON.parse(JSON.stringify(localRestaurants));
            updateFoodTypeFilters();
            updateRestaurantList();
            updateUnsavedChangesUI();
            drawWheel();
        }

        /**
         * Update restaurant list in admin panel with sanitized content
         */
        function updateRestaurantList() {
            const container = document.getElementById('restaurantList');
            container.innerHTML = '<h4 style="margin-bottom: 10px;">Current Restaurants:</h4>';

            restaurants.forEach(r => {
                const profileTags = r.profiles && r.profiles.length > 0
                    ? r.profiles.map(p => sanitizeHTML(p)).join(', ')
                    : 'No profiles';
                const item = document.createElement('div');
                item.className = 'restaurant-item';
                item.innerHTML = `
                    <div class="restaurant-item-info">
                        <div class="restaurant-item-name">${sanitizeHTML(r.name)}</div>
                        <div class="restaurant-item-types">${r.foodTypes.map(ft => sanitizeHTML(ft)).join(', ')} ‚Ä¢ ${r.serviceTypes.map(st => sanitizeHTML(st)).join(', ')}</div>
                        <div class="restaurant-item-types" style="font-size: 0.8em; margin-top: 3px;">Profiles: ${profileTags}</div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button class="btn btn-small" onclick="duplicateRestaurant(${r.id})" style="background: #6c757d;">üìã Duplicate</button>
                        <button class="btn btn-danger btn-small" onclick="deleteRestaurant(${r.id})">Delete</button>
                    </div>
                `;
                container.appendChild(item);
            });

            // Update profile checkboxes in restaurant form
            updateRestaurantProfileCheckboxes();

            // Update bulk edit restaurant list
            updateBulkRestaurantList();
        }

        // Populate profile checkboxes in restaurant form
        function updateRestaurantProfileCheckboxes() {
            const container = document.getElementById('restaurantProfileCheckboxes');
            container.innerHTML = '';

            // Filter out 'all' profile as it's not a taggable profile
            const taggableProfiles = profiles.filter(p => p.id !== 'all');

            if (taggableProfiles.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-size: 0.9em;">No profiles created yet</p>';
                return;
            }

            taggableProfiles.forEach(profile => {
                const label = document.createElement('label');
                label.innerHTML = `
                    <input type="checkbox" value="${profile.id}" class="restaurant-profile-checkbox">
                    ${profile.name}
                `;
                container.appendChild(label);
            });
        }

        function addProfile() {
            const name = document.getElementById('profileName').value.trim();

            if (!name) {
                alert('Please enter a profile name');
                return;
            }

            // Generate profile ID from name
            const profileId = name.toLowerCase().replace(/[^a-z0-9]+/g, '-');

            // Check if profile already exists
            if (localProfiles.find(p => p.id === profileId)) {
                alert('A profile with this name already exists');
                return;
            }

            const newProfile = {
                id: profileId,
                name: name
            };

            // Add to local state and pending changes
            localProfiles.push(newProfile);
            pendingChanges.addedProfiles.push(newProfile);

            // Update UI to show local changes
            profiles = JSON.parse(JSON.stringify(localProfiles));
            updateProfileInput();
            updateProfileList();
            updateRestaurantProfileCheckboxes();
            updateUnsavedChangesUI();

            // Clear form
            document.getElementById('profileName').value = '';
        }

        function deleteProfile(profileId) {
            // Prevent deletion of "all" profile
            if (profileId === 'all') {
                alert('Cannot delete the default "All Restaurants" profile');
                return;
            }

            if (!confirm('Are you sure you want to delete this profile?')) {
                return;
            }

            // Remove from local state
            const index = localProfiles.findIndex(p => p.id === profileId);
            if (index !== -1) {
                localProfiles.splice(index, 1);
            }

            // Track deletion
            pendingChanges.deletedProfiles.push(profileId);

            // Update UI to show local changes
            profiles = JSON.parse(JSON.stringify(localProfiles));
            updateProfileInput();
            updateProfileList();
            updateUnsavedChangesUI();

            // Reset to "all" if deleted profile was selected
            if (selectedProfile === profileId) {
                selectedProfile = 'all';
                updateProfileInput();
                drawWheel();
            }
        }

        /**
         * Update profile list in admin panel with sanitized content
         */
        function updateProfileList() {
            const container = document.getElementById('profileList');
            container.innerHTML = '<h4 style="margin-bottom: 10px;">Current Profiles:</h4>';

            profiles.filter(p => p.id !== 'all').forEach(profile => {
                // Find restaurants tagged with this profile
                const taggedRestaurants = restaurants
                    .filter(r => r.profiles && r.profiles.includes(profile.id))
                    .map(r => sanitizeHTML(r.name));

                const restaurantNames = taggedRestaurants.length > 0
                    ? taggedRestaurants.join(', ')
                    : 'No restaurants tagged';

                const item = document.createElement('div');
                item.className = 'restaurant-item';
                item.innerHTML = `
                    <div class="restaurant-item-info">
                        <div class="restaurant-item-name">${sanitizeHTML(profile.name)}</div>
                        <div class="restaurant-item-types" style="font-size: 0.85em;">${restaurantNames}</div>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="deleteProfile('${sanitizeHTML(profile.id)}')">Delete</button>
                `;
                container.appendChild(item);
            });
        }

        /**
         * Export current data as JSON file
         */
        function exportData() {
            const data = {
                profiles: profiles,
                restaurants: restaurants
            };

            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `restaurants-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Import data from JSON file
         */
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validate data structure
                    if (!data.profiles || !data.restaurants) {
                        alert('Invalid JSON format. Must contain "profiles" and "restaurants" arrays.');
                        return;
                    }

                    if (!confirm(`Import ${data.restaurants.length} restaurants and ${data.profiles.length} profiles? This will replace your current local data.`)) {
                        return;
                    }

                    // Update local state
                    localRestaurants = data.restaurants;
                    localProfiles = data.profiles;
                    restaurants = JSON.parse(JSON.stringify(localRestaurants));
                    profiles = JSON.parse(JSON.stringify(localProfiles));

                    // Clear pending changes since we're starting fresh
                    pendingChanges = {
                        addedRestaurants: [],
                        deletedRestaurants: [],
                        addedProfiles: [],
                        deletedProfiles: []
                    };
                    hasUnsavedChanges = false;

                    // Update UI
                    updateFoodTypeFilters();
                    updateRestaurantList();
                    updateProfileInput();
                    updateProfileList();
                    updateUnsavedChangesUI();
                    drawWheel();

                    alert('Data imported successfully! Remember to click "Save All Changes" to save to GitHub.');
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Failed to import data. Please check the file format.');
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        /**
         * Register service worker for offline support
         */
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        }

        // Start the app
        init();
        registerServiceWorker();
    </script>

    <footer class="footer">
        <div class="footer-left"></div>
        <div class="footer-center">
            <a href="https://github.com/BenSweaterVest/restaurant-decision-wheel" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
        <div class="footer-right">
            <a href="#" onclick="showLogin(); return false;">Admin Login</a>
        </div>
    </footer>
</body>
</html>
